from fastapi import FastAPI, Depends, HTTPException, status, Request
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, JSONResponse, Response 
from starlette.responses import RedirectResponse
from sqladmin import Admin, ModelView
from sqladmin import action
from sqlalchemy import select, func
from src.referalbot.api.routes import router, log_to_google_sheet, log_bonus_history
from src.referalbot.database.db import async_session, init_db, engine
from starlette.middleware.sessions import SessionMiddleware # <--- ДОБАВЛЕН ИМПОРТ
from src.referalbot.database.models import User, Purchase, BonusHistory
from sqladmin.authentication import AuthenticationBackend
from sqlalchemy.orm import Session
from sqlalchemy.orm import selectinload
import datetime
from aiogram import Bot
from referalbot.config import TELEGRAM_TOKEN
import asyncio
import os

app = FastAPI()

app.add_middleware(SessionMiddleware, secret_key="a_very_secret_key_for_sessions")

templates = Jinja2Templates(directory="src/referalbot/api/templates")
bot = Bot(token=TELEGRAM_TOKEN) # Создаем экземпляр бота для отправки сообщений


class AdminAuth(AuthenticationBackend):
    def __init__(self, secret_key: str):
        super().__init__(secret_key=secret_key)

    async def login(self, request: Request) -> bool:
        form = await request.form()
        username, password = form.get("username"), form.get("password")
        correct_username = "admin"
        correct_password = "admin123"
        if username == correct_username and password == correct_password:
            request.session.update({"token": "admin_token"})
            return True
        return False

    async def logout(self, request: Request) -> bool:
        request.session.clear()
        return True

    async def authenticate(self, request: Request) -> bool:
        token = request.session.get("token")
        return token == "admin_token"

templates_dir = os.path.abspath("src/referalbot/api/templates")

admin = Admin(
    app=app,
    engine=engine,
    authentication_backend=AdminAuth(secret_key="ddkdk22"),
    templates_dir=templates_dir,
    base_url="/admin"
)

class UserAdmin(ModelView, model=User):
    name = "Пользователь"
    name_plural = "Пользователи"
    icon = "fa-solid fa-user"
    column_list = [User.id, User.telegram_id, User.username, User.total_bonus]
    column_searchable_list = ["username", "promo_code", "telegram_id"]
    column_details_list = [
        User.id, User.telegram_id, User.username, User.promo_code,
        "invited_by", "referrals", "bonus_history", User.total_bonus
    ]
    
    column_formatters = {
        "referrals": lambda m, a: "<br>".join(
            [f"{ref.username} (ID: {ref.telegram_id})" for ref in m.referrals]
        ) if m.referrals else "-",
        "bonus_history": lambda m, a: "<br>".join(
            [f"{h.date.strftime('%Y-%m-%d')}: {h.amount:+,} IDR ({h.operation})" 
             for h in sorted(m.bonus_history, key=lambda x: x.date, reverse=True)]
        ) if m.bonus_history else "Нет операций",
        User.total_bonus: lambda m, a: f"{m.total_bonus:}"
    }
    
    async def get_query_for_list(self, session, *args, **kwargs):
        """Запрос для списка пользователей с вычислением total_bonus"""
        return await session.execute(
            select(User).add_columns(User.total_bonus)
        )
    
    async def get_query_for_details(self, session, pk):
        """Запрос для детального просмотра с загрузкой связей"""
        return await session.execute(
            select(User)
            .options(
                selectinload(User.invited_by),
                selectinload(User.referrals),
                selectinload(User.bonus_history)
            )
            .filter_by(id=pk)
        )
        
    @action(
        name="reset_bonus",
        label="Сбросить бонусы",
        confirmation_message="Вы уверены? Это отметит все доступные бонусы как выплаченные.",
    )
    async def reset_bonus_action(self, request: Request):
        pks = request.query_params.getlist("pks")
        async with async_session() as session:
            for pk in pks:
                purchases_res = await session.execute(
                    select(Purchase)
                    .join(User, Purchase.user_id == User.id)
                    .filter(User.invited_by_id == int(pk), Purchase.bonus_paid == False)
                )
                for purchase in purchases_res.scalars().all():
                    if purchase.bonus_amount > 0:
                        await log_bonus_history(session, int(pk), purchase.bonus_amount, "Выплата (Админ)", f"Покупка ID: {purchase.id}")
            await session.commit()
        return JSONResponse({"message": "Бонусы сброшены и отмечены как выплаченные."})

    @action(
        name="delete_bonus",
        label="Удалить бонусы",
        confirmation_message="Вы уверены, что хотите удалить бонусы для выбранных пользователей?",
        add_in_detail=True,
        add_in_list=True,
    )
    async def delete_bonus_action(self, request):
        pks = request.query_params.getlist('pks')
        if not pks:
            return JSONResponse({"message": "Не выбраны пользователи"}, status_code=400)
        async with async_session() as session:
            for pk in pks:
                result = await session.execute(
                    select(Purchase).join(User, Purchase.user_id == User.id)
                    .filter(User.invited_by_id == int(pk), Purchase.bonus_paid == False)
                )
                purchases = result.scalars().all()
                for purchase in purchases:
                    old_bonus = purchase.bonus_amount
                    if old_bonus > 0:
                        await log_bonus_history(
                            session,
                            int(pk),
                            -old_bonus,
                            "Удаление (Админ)",
                            f"Удаление бонуса по покупке ID: {purchase.id}"
                        )
                    purchase.bonus_amount = 0
                    print(f"Purchase {purchase.id}: bonus_amount {old_bonus} -> 0")
                    user = await session.execute(select(User).filter_by(id=purchase.user_id))
                    user = user.scalar_one_or_none()
                    if user:
                        pass
                await session.commit()
        return JSONResponse({"message": "Бонусы удалены"})

    @action(
        name="reduce_bonus",
        label="Уменьшить бонусы",
        confirmation_message="Перейти к форме для уменьшения бонусов?",
        add_in_detail=True,
        add_in_list=True,
    )
    async def reduce_bonus_action(self, request):
        pks = request.query_params.getlist('pks')
        if not pks:
            return JSONResponse({"message": "Не выбраны пользователи"}, status_code=400)
        pks_query = "&".join([f"pks={pk}" for pk in pks])
        redirect_url = f"/custom/reduce_bonus_form?{pks_query}"
        print(f"Redirecting to: {redirect_url}")
        return RedirectResponse(url=redirect_url, status_code=302)

class PurchaseAdmin(ModelView, model=Purchase):
    name = "Покупка"
    name_plural = "Покупки"
    icon = "fa-solid fa-shopping-cart"
    
    column_list = [Purchase.id, "user", Purchase.name, Purchase.amount, Purchase.bonus_amount, Purchase.date]
    form_excluded_columns = [Purchase.bonus_amount, Purchase.date]

    async def create(self, request: Request) -> Response:
        if request.method == "GET":
            # --- ОТЛАДКА ---
            print("Отрисовка новой формы (GET). Данные в сессии:", request.session.get("last_purchase_data"))
            
            Form = await self.scaffold_form()
            initial_data = request.session.get("last_purchase_data", {})
            form = Form(request, data=initial_data)
            context = {"request": request, "model_view": self, "form": form}
            return await self.templates.render(self.create_template, context=context)
        
        return await super().create(request)

    async def list(self, request: Request) -> Response:
        # --- ОТЛАДКА ---
        if "last_purchase_data" in request.session:
            print("Возврат к списку. Очистка данных из сессии.")
            request.session.pop("last_purchase_data", None)
        return await super().list(request)
    
    async def on_model_change(self, data: dict, model: Purchase, is_created: bool, request: Request) -> None:
        async with async_session() as session:
            user = await session.get(User, int(data.get("user")))
            if user and user.invited_by_id:
                model.bonus_amount = int(round(int(data.get("amount", 0)) * 0.05))
            else:
                model.bonus_amount = 0

    async def after_model_change(self, data: dict, model: Purchase, is_created: bool, request: Request) -> None:
        if is_created:
            form = await request.form()
            if "save-and-add-another" in form:
                session_data = {
                    "user": model.user_id,
                    "name": model.name,
                    "amount": model.amount,
                    "discount_applied": model.discount_applied
                }
                request.session["last_purchase_data"] = session_data
                # --- ОТЛАДКА ---
                print("Нажата 'Save and add another'. Сохраненные данные:", session_data)
            
            elif "save" in form:
                if "last_purchase_data" in request.session:
                    request.session.pop("last_purchase_data", None)
                    # --- ОТЛАДКА ---
                    print("Нажата 'Save'. Данные из сессии очищены.")

        if not is_created or model.bonus_amount <= 0:
            return

        async with async_session() as session:
            purchase_db = await session.get(Purchase, model.id, options=[selectinload(Purchase.user).selectinload(User.invited_by)])
            if not (purchase_db and purchase_db.user and purchase_db.user.invited_by):
                request.session.pop("last_purchase_data", None)
                return
            
            inviter = purchase_db.user.invited_by
            user = purchase_db.user

            await log_bonus_history(
                session, inviter.id, model.bonus_amount,
                "Начисление", f"За покупку от {user.username}"
            )

            if inviter.telegram_id:
                try:
                    await bot.send_message(
                        chat_id=inviter.telegram_id,
                        text=f"🎉 Вам начислен бонус: +{model.bonus_amount:,} IDR"
                    )
                except Exception as e:
                    print(f"Ошибка отправки уведомления: {e}")
            
            await session.commit()

@app.get("/custom/reduce_bonus_form", response_class=HTMLResponse)
async def reduce_bonus_form(request: Request):
    print(f"Redirected to /custom/reduce_bonus_form with query: {request.query_params}")
    return templates.TemplateResponse(
        "reduce_bonus_form.html",
        {"request": request}
    )

@app.post("/custom/reduce_bonus", response_class=HTMLResponse)
async def reduce_bonus(request: Request):
    form = await request.form()
    amount_to_reduce = int(form.get("amount", 100))
    pks = form.getlist("pks")
    if not pks:
        return templates.TemplateResponse(
            "reduce_bonus_success.html",
            {"request": request, "message": "Не выбраны пользователи"}
        )
    
    if amount_to_reduce <= 0:
        return templates.TemplateResponse(
            "reduce_bonus_success.html",
            {"request": request, "message": "Сумма для уменьшения должна быть положительной"}
        )

    async with async_session() as session:
        for pk in pks:
            result = await session.execute(
                select(Purchase)
                .join(User, Purchase.user_id == User.id)
                .filter(User.invited_by_id == int(pk))
                .order_by(Purchase.date)
            )
            purchases = result.scalars().all()
            
            remaining_amount_to_reduce = amount_to_reduce
            
            for purchase in purchases:
                if remaining_amount_to_reduce <= 0:
                    break
                
                old_bonus = purchase.bonus_amount
                reduction = min(old_bonus, remaining_amount_to_reduce)
                
                if reduction > 0:
                    purchase.bonus_amount = old_bonus - reduction
                    print(f"Purchase {purchase.id}: bonus_amount {old_bonus} -> {purchase.bonus_amount}")
                    
                    await log_bonus_history(
                        session,
                        int(pk),
                        -reduction,
                        "Уменьшение (Админ)",
                        f"Уменьшение по покупке ID {purchase.id}"
                    )
                    
                    remaining_amount_to_reduce -= reduction
            
            await session.commit()
            
            if remaining_amount_to_reduce > 0:
                message = f"Бонусы уменьшены на {amount_to_reduce - remaining_amount_to_reduce} IDR. " \
                          f"Невозможно списать оставшиеся {remaining_amount_to_reduce} IDR (недостаточно бонусов)."
            else:
                message = f"Бонусы успешно уменьшены на {amount_to_reduce} IDR."

    return templates.TemplateResponse(
        "reduce_bonus_success.html",
        {"request": request, "message": message}
    )

class BonusHistoryAdmin(ModelView, model=BonusHistory):
    can_create = False
    can_edit = False
    can_delete = False
    column_list = [BonusHistory.date, "user", BonusHistory.amount, BonusHistory.operation, BonusHistory.description]

    column_formatters = {
        "user": lambda m, a: f"{m.user.username} (ID: {m.user_id})" if m.user else f"ID: {m.user_id}"
    }
    
    async def get_query_for_list(self, session, *args, **kwargs):
        return await session.execute(
            select(self.model)
            .options(selectinload(BonusHistory.user))
        )
    
    async def get_query_for_details(self, session, pk):
        return await session.execute(
            select(self.model)
            .options(selectinload(BonusHistory.user))
            .filter_by(id=pk)
        )

admin.add_view(UserAdmin)
admin.add_view(PurchaseAdmin)
admin.add_view(BonusHistoryAdmin)

app.include_router(router)

@app.on_event("startup")
async def startup_event():
    await init_db()